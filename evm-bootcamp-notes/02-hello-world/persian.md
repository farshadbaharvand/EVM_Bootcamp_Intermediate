# درس ۲ - ساخت قرارداد HelloWorld.sol در Remix

این درس به صورت گام‌به‌گام برای دانشجویانی طراحی شده که با برنامه‌نویسی آشنایی دارند اما تازه وارد دنیای اتریوم و Solidity شده‌اند. در این درس، از فلسفه زبان تا نوشتن قرارداد، مدیریت متغیرها، ذخیره‌سازی، توابع و تعامل با قراردادها پوشش داده شده است.

---

## 1. فلسفه Solidity (Solidity Philosophy)

**Solidity** یک زبان برنامه‌نویسی سطح بالا برای نوشتن قراردادهای هوشمند بر روی بلاک‌چین اتریوم است. هدف آن ایجاد کدی امن، قابل فهم و قابل اجرا بر روی **EVM** است.

💡 نکته: Solidity ترکیبی از JavaScript، Python و C++ است. این ترکیب باعث می‌شود یادگیری آن برای توسعه‌دهندگان آشنا با این زبان‌ها راحت‌تر باشد.

⚠️ هشدار: قراردادهای هوشمند پس از استقرار قابل تغییر نیستند، بنابراین دقت و امنیت در کدنویسی حیاتی است.

📘 توصیه: قبل از انتشار روی شبکه اصلی، حتماً قرارداد را روی شبکه‌های آزمایشی مثل Sepolia یا Goerli تست کنید.

---

## 2. مبانی OOP در Solidity

Solidity از مفاهیم **Object-Oriented Programming (OOP)** استفاده می‌کند:

- **Contract** → مشابه کلاس در OOP است.
- **State Variables** → ویژگی‌ها (Attributes) کلاس هستند.
- **Functions** → متدهای کلاس هستند.
- **Inheritance** → امکان ارث‌بری بین قراردادها وجود دارد.
- **Modifiers** → شرایط و محدودیت‌ها را قبل از اجرای توابع اعمال می‌کنند.

💡 نکته: هر قرارداد مانند یک شیء مستقل عمل می‌کند و توابع آن می‌توانند وضعیت بلاک‌چین را تغییر دهند.

---

## 3. ساختار قرارداد (Contract Structure)

### 3.1 SPDX License Identifier

این بخش مشخص می‌کند قرارداد تحت چه مجوزی است:

// SPDX-License-Identifier: GPL-3.0

💡 توصیه: همیشه مجوز قرارداد را مشخص کنید تا مسائل حقوقی روشن باشد.

---

### 3.2 Pragma

نسخه کامپایلر مورد نیاز را مشخص می‌کند:

pragma solidity >=0.7.0 <0.9.0

⚠️ هشدار: استفاده از نسخه غیرسازگار با توابع یا کتابخانه‌ها باعث خطا در کامپایل می‌شود.

---

### 3.3 Imports

برای استفاده از کتابخانه‌ها و قراردادهای خارجی:

import "path_to_library";

💡 مثال عملی: استفاده از OpenZeppelin برای پیاده‌سازی استاندارد ERC20.

---

### 3.4 Comments

کامنت‌ها برای خوانایی و مستندسازی کد استفاده می‌شوند:

// این یک کامنت تک‌خطی است
/* این یک کامنت چندخطی است */

---

### 3.5 تعریف قرارداد

contract HelloWorld {
    // محتوای قرارداد
}

💡 نکته: قرارداد مانند کلاس OOP است و می‌تواند شامل متغیرها، توابع و سازنده باشد.

---

## 4. متغیرها (Variables)

متغیرها داده‌های قرارداد را ذخیره می‌کنند. انواع رایج:

- uint → اعداد صحیح مثبت
- int → اعداد صحیح
- string → رشته‌ها
- bool → درست/نادرست

مثال:

string public text;
uint private counter;

💡 نکته: **Visibility** متغیرها (public/private/internal) مشخص می‌کند چه کسانی می‌توانند به آن دسترسی داشته باشند.

---

## 5. حافظه و Storage (Storage Areas)

### 5.1 Account storage

محل ذخیره‌سازی دائمی در بلاک‌چین است. تغییرات آن هزینه Gas بیشتری دارد.

### 5.2 Memory

حافظه موقت برای اجرای توابع است و پس از پایان تابع پاک می‌شود.

### 5.3 Stack

حافظه محلی EVM برای نگه‌داشتن داده‌های کوچک و سریع.

💡 مثال: متغیرهایی که فقط در یک تابع استفاده می‌شوند در memory ذخیره می‌شوند، اما متغیرهایی که وضعیت قرارداد را نگه می‌دارند در storage ذخیره می‌شوند.

---

## 6. تابع سازنده (Constructor Function)

سازنده هنگام ایجاد قرارداد اجرا می‌شود و معمولاً متغیرهای اولیه را مقداردهی می‌کند.

مثال:

constructor() {
    text = "Hello World";
}

💡 نکته: هر قرارداد فقط یک سازنده می‌تواند داشته باشد.

---

## 7. توابع (Functions)

توابع عملیات قرارداد را انجام می‌دهند.

مثال:

function helloWorld() public view returns (string memory) {
    return text;
}

توضیح:

- **public** → قابل دسترسی از خارج قرارداد
- **view** → وضعیت بلاک‌چین را تغییر نمی‌دهد
- **returns** → نوع خروجی تابع

### مثال تغییر مقدار

function setText(string memory newText) public {
    text = newText;
}

توضیح: این تابع وضعیت ذخیره‌شده در بلاک‌چین را تغییر می‌دهد.

---

## 8. Visibility

Visibility مشخص می‌کند چه کسانی می‌توانند به متغیرها و توابع دسترسی داشته باشند:

| Visibility  | توضیح |
|------------|-------|
| public     | همه می‌توانند دسترسی داشته باشند |
| private    | فقط داخل قرارداد قابل دسترسی است |
| internal   | داخل قرارداد و قراردادهای ارث‌برده قابل دسترسی است |
| external   | فقط از خارج قرارداد قابل فراخوانی است |

💡 نکته: انتخاب درست visibility برای امنیت قرارداد حیاتی است.

---

## 9. Typing

Solidity نوع داده‌ها را به شدت بررسی می‌کند:

- uint256 → عدد صحیح بدون علامت
- int256 → عدد صحیح با علامت
- address → آدرس کیف‌پول یا قرارداد
- bytes32 → داده باینری با طول ثابت

💡 توصیه: همیشه نوع متغیر را با دقت مشخص کنید تا خطاهای احتمالی کاهش یابد.

---

## 10. Return values

توابع می‌توانند مقدار یا مقادیر متعددی را برگردانند:

function getText() public view returns (string memory, uint) {
    return (text, counter);
}

💡 نکته: توابع view یا pure وضعیت بلاک‌چین را تغییر نمی‌دهند و هزینه Gas ندارند.

---

## 11. مثال نهایی قرارداد HelloWorld.sol

contract HelloWorld {
    string private text;

    constructor() {
        text = "Hello World";
    }

    function helloWorld() public view returns (string memory) {
        return text;
    }

    function setText(string memory newText) public {
        text = newText;
    }
}

توضیح: این قرارداد یک متن ذخیره می‌کند و اجازه خواندن و تغییر آن را می‌دهد.

💡 توصیه: قبل از استقرار روی شبکه اصلی، قرارداد را حتماً روی شبکه‌های آزمایشی تست کنید.

---

## 12. تعامل با قراردادها (Contract Interaction)

### بخش ۱: محیط شبیه‌سازی Remix

- امکان فراخوانی توابع و مشاهده تغییرات وضعیت
- تست اولیه بدون هزینه Gas

### بخش ۲: شبکه‌های آزمایشی عمومی

- اجرای تراکنش‌های تغییر وضعیت روی شبکه‌های آزمایشی
- استفاده از **interfaces** برای تعامل با قراردادهای دیگر

interface HelloWorldInterface {
    function helloWorld() external view returns (string memory);
    function setText(string memory newText) external;
}

contract HelloWorld is HelloWorldInterface {
    // پیاده‌سازی متدها
}

### بخش ۳: توابع Payable

- توابعی که می‌توانند Ether دریافت کنند

function setText(string memory newText) public payable {
    text = newText;
}

💡 نکته: استفاده از payable برای دریافت ETH ضروری است.

---

## 13. نوشتن کد تمیز و مستندسازی

- رعایت **Style Guide**
- استفاده از **NatSpec Format** برای مستندسازی توابع و متغیرها

📘 منابع:

<https://docs.soliditylang.org/en/latest/style-guide.html>
<https://docs.soliditylang.org/en/latest/natspec-format.html#natspec>

---

## خلاصه و نکات کلیدی

- Solidity زبان اصلی قراردادهای هوشمند است.  
- قراردادها مانند کلاس‌های OOP عمل می‌کنند.  
- متغیرها، حافظه و توابع باید با دقت تعریف شوند.  
- Visibility و نوع حافظه برای امنیت و هزینه Gas حیاتی هستند.  
- توابع view و pure ارزان‌تر هستند و وضعیت بلاک‌چین را تغییر نمی‌دهند.  
- همیشه قبل از Mainnet، روی شبکه‌های آزمایشی تست انجام دهید.
